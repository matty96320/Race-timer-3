<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Enduro Race Timer</title>
  <link rel="manifest" href="timer-manifest.json">
  <meta name="theme-color" content="#4c51bf">
<script src="https://cdn.tailwindcss.com"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
body {
font-family: 'Inter', sans-serif;
background-color: #f3f4f6;
color: #374151;
}
.container {
max-width: 1200px;
}
.card {
background-color: #ffffff;
border-radius: 12px;
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
border: 1px solid #e5e7eb;
padding: 2rem;
}
.button {
transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
}
.button:hover {
transform: translateY(-2px);
box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
}
.header-bg {
background: linear-gradient(to right, #4c51bf, #6b46c1);
}
table {
border-collapse: separate;
border-spacing: 0;
}
th, td {
padding: 0.75rem 1rem;
text-align: left;
border-bottom: 1px solid #e5e7eb;
}
tbody tr:last-child td {
border-bottom: none;
}
th:first-child, td:first-child {
border-top-left-radius: 8px;
border-bottom-left-radius: 8px;
}
th:last-child, td:last-child {
border-top-right-radius: 8px;
border-bottom-right-radius: 8px;
}
thead th {
background-color: #f9fafb;
color: #4b5563;
font-weight: 600;
text-transform: uppercase;
font-size: 0.75rem;
letter-spacing: 0.05em;
}
tbody tr:nth-child(even) {
background-color: #f9fafb;
}
/* Tab styling */
.tab-button {
border-radius: 8px;
font-weight: 600;
cursor: pointer;
transition: all 0.2s ease-in-out;
border: 2px solid transparent;
}
.tab-button.active {
background-color: #ffffff;
color: #4f46e5;
box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}
.tab-button:not(.active) {
color: #6b7280;
}
.tab-button:not(.active):hover {
background-color: #f0f0f5;
}
.pill-button {
background-color: #e0e7ff;
color: #3730a3;
border-radius: 9999px;
padding: 0.25rem 0.75rem;
font-size: 0.75rem;
font-weight: 500;
display: inline-flex;
align-items: center;
margin: 0.25rem;
}
.pill-button button {
margin-left: 0.5rem;
color: #c7d2fe;
font-weight: bold;
}
.pill-button button:hover {
color: #3730a3;
}
/* Seeding button styles */
.seed-btn {
margin-left: 0.25rem;
padding: 0 0.25rem;
border-radius: 4px;
background-color: #dbeafe;
color: #1e40af;
font-weight: bold;
}
.seed-btn:hover {
background-color: #bfdbfe;
}
.rider-seed-item {
display: flex;
align-items: center;
justify-content: space-between;
padding: 0.5rem;
border-bottom: 1px solid #e5e7eb;
}
.rider-seed-item:last-child {
border-bottom: none;
}
</style>
</head>
<body class="bg-gray-100 min-h-screen p-100vh p-4 sm:p-8 flex flex-col items-center">

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, doc, onSnapshot, setDoc, updateDoc, collection, getDoc, deleteDoc, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

// --- Firebase Instances ---
let app, db, auth;

// --- Global State ---
let raceData = { riders: [], stages: 6, seedingCategories: [], resultsCategories: [] };
let authReady = false;
let raceUnsubscribe = null, timersUnsubscribe = null;
let userId = null, currentRaceId = null, currentTimingStage = null;
let currentOfflineTimingStage = null; 
let activeTimers = {};
const MAX_RIDERS = 250; 

// --- DOM Elements ---
let raceIdInput, loadRaceBtn, newRaceBtn, raceInfoDiv, raceTimerContainer;
let riderForm, ridersTableBody, resultsTableBody, riderCountDisplay;
let startTimerBtn, timingRiderInput, messageBox, activeTimersList, stageCountInput, exportCsvBtn;
let stageSelectionContainer, timingStationSelect, startTimingStationBtn, timingStationActive, timingStationHeader, switchStageBtn;
let stageStandingsHeader, stageStandingsBody;
let riderCsvInput, processCsvBtn; 
let toggleViewBtn, tabButtons, tabContents;
let raceNameInput, currentRaceNameDisplay;
let editStageCountBtn;
let seedingCategoryNameInput, addSeedingCategoryBtn, seedingCategoryListContainer, riderMgmtSeedingCategorySelect;
let resultsCategoryNameInput, addResultsCategoryBtn, resultsCategoryListContainer, riderMgmtResultsCategorySelect;

// --- OFFLINE/SETUP Elements ---
let offlineStageSelectionContainer, offlineTimingStationSelect, startOfflineTimingBtn, offlineTimingStationActive;
let offlineTimingStationHeader, switchOfflineStageBtn, offlineRiderInput, offlineStartBtn, offlineFinishBtn, offlineFinishSelectedBtn;
let pendingSyncList, manualSyncBtn;
let renumberRidersBtn;
let publicMessageInput, savePublicMessageBtn;
let riderSeedingListContainer;

// --- LocalStorage Helper Functions ---
const getPendingTimers = () => {
return JSON.parse(localStorage.getItem('pendingTimers') || '[]');
};
const savePendingTimers = (logs) => {
localStorage.setItem('pendingTimers', JSON.stringify(logs));
};

const showMessage = (message, isError = false) => {
if (!messageBox) return;
messageBox.textContent = message;
messageBox.className = `p-3 rounded-md text-center font-semibold mb-4 transition-all duration-300 ${isError ? 'bg-red-500 text-white' : 'bg-green-500 text-white'}`;
messageBox.classList.remove('opacity-0', 'scale-95');
messageBox.classList.add('opacity-100', 'scale-100');
setTimeout(() => {
messageBox.classList.remove('opacity-100', 'scale-100');
messageBox.classList.add('opacity-0', 'scale-95');
}, 3000);
};

const setupRaceListener = (raceId, newRaceName = null) => {
if (raceUnsubscribe) raceUnsubscribe();
currentRaceId = raceId;
const appId = typeof __app_id !== 'undefined' ? __app_id : 'enduro-timer-default';
const raceDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'races', raceId);

raceUnsubscribe = onSnapshot(raceDocRef, (docSnap) => {
if (docSnap.exists()) {
raceData = docSnap.data();
if (!raceData.seedingCategories) raceData.seedingCategories = [];
if (!raceData.resultsCategories) raceData.resultsCategories = [];
if (!raceData.riders) raceData.riders = [];

currentRaceNameDisplay.textContent = raceData.raceName || 'Race'; 
if (publicMessageInput) publicMessageInput.value = raceData.raceMessage || '';

if(currentTimingStage === null) {
showStageSelection();
}
if(currentOfflineTimingStage === null) {
showOfflineStageSelection();
}
renderRaceData();
populateTimingDropdown();
populateOfflineRiderDropdown(); 
renderPendingTimers(); 
syncOfflineTimers(); 
} else {
console.log("No such document! Creating a new one.");
const finalRaceName = newRaceName || 'Untitled Race';
raceData = { 
riders: [], 
stages: raceData.stages, 
raceId: raceId, 
raceName: finalRaceName,
seedingCategories: [], 
resultsCategories: [],
raceMessage: '' 
};
setDoc(raceDocRef, raceData);
}
}, (error) => console.error("Error listening for real-time updates: ", error));
setupTimersListener(raceId);
};

const setupTimersListener = (raceId) => {
if (timersUnsubscribe) timersUnsubscribe();
const appId = typeof __app_id !== 'undefined' ? __app_id : 'enduro-timer-default';
const timersCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'races', raceId, 'timers');
timersUnsubscribe = onSnapshot(timersCollectionRef, (querySnapshot) => {
activeTimers = {};
querySnapshot.forEach((doc) => {
activeTimers[doc.id] = { ...doc.data(), id: doc.id };
});
renderActiveTimers();
}, (error) => console.error("Error listening for active timers: ", error));
};

const renderActiveTimers = () => {
if (!activeTimersList || currentTimingStage === null) return;
activeTimersList.innerHTML = '';

const stageTimers = Object.values(activeTimers).filter(timer => timer.stageIndex === currentTimingStage);

if (stageTimers.length === 0) {
activeTimersList.innerHTML = `<li class="text-sm text-gray-500">No active timers for this stage.</li>`;
} else {
stageTimers.forEach(timer => {
const elapsed = Math.floor((Date.now() - timer.startTime) / 1000);
const timeString = formatTime(elapsed);
const rider = raceData.riders.find(r => r.number === timer.riderNumber);
const riderDetails = rider ? `(${rider.name}${rider.resultsCategory ? ', ' + rider.resultsCategory : ''})` : '';
const listItem = document.createElement('li');
listItem.className = "flex justify-between items-center p-2 bg-gray-100 rounded-md shadow-sm";
const textNode = document.createElement('span');
textNode.textContent = `Rider #${timer.riderNumber} ${riderDetails} : ${timeString}`;
const stopButton = document.createElement('button');
stopButton.textContent = 'Stop';
stopButton.className = 'button px-3 py-1 bg-red-600 text-white text-sm font-bold rounded-md shadow-sm hover:bg-red-700';
stopButton.onclick = () => stopSpecificTimer(timer.riderNumber, timer.stageIndex);
listItem.appendChild(textNode);
listItem.appendChild(stopButton);
activeTimersList.appendChild(listItem);
});
}
};

const stopSpecificTimer = async (riderNumber, stageIndex, finishTimestamp = null) => {
if (!riderNumber) {
console.warn("stopSpecificTimer called with no riderNumber. This might be a pending log.");
return;
}
const timerDocId = `${riderNumber}-${stageIndex}`;
const appId = typeof __app_id !== 'undefined' ? __app_id : 'enduro-timer-default';
const timerDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'races', currentRaceId, 'timers', timerDocId);

try {
const docSnap = await getDoc(timerDocRef);
if (docSnap.exists()) {
const timerData = docSnap.data();
const endTime = finishTimestamp || Date.now(); 
const elapsedSeconds = Math.floor((endTime - timerData.startTime) / 1000);

if (elapsedSeconds < 0) {
showMessage(`Error for Rider #${riderNumber}: Finish time is before start time.`, true);
if (finishTimestamp) { 
await deleteDoc(timerDocRef);
}
return; 
}

await updateTime(riderNumber, timerData.stageIndex, elapsedSeconds);
showMessage(`Time saved for Rider #${riderNumber}, Stage ${timerData.stageIndex + 1}`);
} else {
if (!finishTimestamp) {
showMessage(`No active timer found for Rider #${riderNumber} on Stage ${stageIndex + 1}.`, true);
}
}
} catch (error) {
console.error("Error stopping timer: ", error);
showMessage('Failed to stop timer.', true);
} finally {
if (timerDocRef) {
const docSnap = await getDoc(timerDocRef);
if (docSnap.exists()) {
await deleteDoc(timerDocRef);
}
}
}
};

// SHARED DROPDOWN POPULATION (sorted by bib number
const populateRiderDropdown = (selectElement) => {
if (!selectElement) return;
const current = selectElement.value;
selectElement.innerHTML = '<option value="">Select Rider...</option>';

[...raceData.riders]
.sort((a, b) => a.number - b.number)
.forEach(rider => {
const opt = document.createElement('option');
opt.value = rider.number;
const cat = rider.resultsCategory ? ` (${rider.resultsCategory})` : '';
opt.textContent = `${rider.number} - ${rider.name}${cat}`;
selectElement.appendChild(opt);
});

selectElement.value = current;
};

const populateTimingDropdown = () => populateRiderDropdown(timingRiderInput);
const populateOfflineRiderDropdown = () => populateRiderDropdown(offlineRiderInput);

const populateAllCategoryDropdowns = () => {
if (riderMgmtSeedingCategorySelect) {
const currentSelection = riderMgmtSeedingCategorySelect.value;
riderMgmtSeedingCategorySelect.innerHTML = '<option value="">-- No Seeding Cat. --</option>';
raceData.seedingCategories.forEach(category => {
const option = document.createElement('option');
option.value = category;
option.textContent = category;
riderMgmtSeedingCategorySelect.appendChild(option);
});
riderMgmtSeedingCategorySelect.value = currentSelection;
}

if (riderMgmtResultsCategorySelect) {
const currentSelection = riderMgmtResultsCategorySelect.value;
riderMgmtResultsCategorySelect.innerHTML = '<option value="">-- No Results Cat. --</option>';
raceData.resultsCategories.forEach(category => {
const option = document.createElement('option');
option.value = category;
option.textContent = category;
riderMgmtResultsCategorySelect.appendChild(option);
});
riderMgmtResultsCategorySelect.value = currentSelection;
}
};

const loadRace = (newRaceName = null, newStages = null) => {
const raceId = raceIdInput.value.trim();
if (!raceId) {
showMessage('Please enter a race ID.', true);
return;
}

if (newStages !== null) {
raceData.stages = newStages; 
}

raceInfoDiv.classList.add('hidden');
raceTimerContainer.classList.remove('hidden');
document.getElementById('currentRaceIdDisplay').textContent = `Race ID: ${raceId}`;
setupRaceListener(raceId, newRaceName);
};

const createNewRace = () => {
const stages = parseInt(stageCountInput.value, 10);
let raceName = raceNameInput.value.trim(); 
if (!raceName) { 
raceName = 'Untitled Race'; 
}
if (isNaN(stages) || stages <= 0) {
showMessage('Please enter a valid number of stages.', true);
return;
}

const newRaceId = `race_${Date.now()}`;
raceIdInput.value = newRaceId;
loadRace(raceName, stages);
};

const addRidersBulk = async (newRiders) => {
if (!currentRaceId) return showMessage('Please create or load a race first.', true);

const updatedRiders = [...raceData.riders, ...newRiders];
const appId = typeof __app_id !== 'undefined' ? __app_id : 'enduro-timer-default';
const raceDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'races', currentRaceId);
await updateDoc(raceDocRef, { riders: updatedRiders });
};

const processCsvUpload = () => {
const file = riderCsvInput.files[0];
if (!file) {
return showMessage('Please select a CSV file to upload.', true);
}

const reader = new FileReader();
reader.onload = async (event) => {
const csv = event.target.result;
const lines = csv.split(/\r\n|\n/);
const newRiders = [];
const existingNumbers = new Set(raceData.riders.map(r => r.number));

for (let i = 1; i < lines.length; i++) {
const line = lines[i].trim();
if (!line) continue;
const parts = line.split(',');
if (parts.length < 2) {
showMessage(`Error on line ${i + 1}: Line must contain at least a number and a name.`, true);
return;
}
const riderNumber = parseInt(parts[0], 10);
const riderName = parts[1].trim();
const riderSeedingCategory = (parts[2] || '').trim();
if (isNaN(riderNumber) || !riderName) {
showMessage(`Error on line ${i + 1}: Invalid rider number or name.`, true);
return;
}
if (existingNumbers.has(riderNumber)) {
showMessage(`Error on line ${i + 1}: Rider number ${riderNumber} already exists.`, true);
return;
}
newRiders.push({
number: riderNumber, name: riderName, 
seeding